//
// Loom Story Engine
//
// " trust in code "
//

var LoomSE = (function() {

    //
    // Private
    //

    // Private variables
    var status = {
            version: '0.31',
            control: 'waiting', // playing | paused | seeking | waiting (initial load of media) | error
            media: null, // current type of media in queue
            id: null, // id of media in queue
        },
        applicationId = 'loomSE', // id root for all ids generated by app
        devOptions = {
            // developer options only
            // some of these options eventually make it into the core product, but for now remain as hidden options
            muteAudio: true, // overrides any settings in script
            verbose: 'minimal', // reports errors, findings, events etc to console. Options are full | minimal | subtitles
            disableCheckScript: false, // by default script file is checked for errors, set to true to skip this
            disableScrubScreen: false, // disables clearing the screen when media is scrubbed
            useAlternativePoster: true, // alternative poster
            showPosterWhenPaused: false // show poster when media is paused?
        },
        mediaLoadType = 'full', // full | progressive
        script,
        firstScene,
        currentScene,
        mediaTimeEventResolution = 0.4, // this is margin for which events are detected on the timecode of the media playing, if flag lockEventToMediaTime is set to true
        id = {
            theatre: applicationId + '_theatre',
            stage: applicationId + '_stage',
            overlay: applicationId + '_overlay',
            mediaGroup: applicationId + '_mediaGroup',
            video: applicationId + '_video',
            audio: applicationId + '_audio'
        },
        modules;

    // Helper functions
    var helper = {
        ajaxRequest: function(file, fileType, async, callback) {
            var data,
                xmlhttp = new XMLHttpRequest();

            xmlhttp.onreadystatechange = function() {
                if(xmlhttp.readyState === 4 && xmlhttp.status === 200) {
                    if(fileType === 'JSON'){
                        data = JSON.parse(xmlhttp.responseText);
                    }
                    else {
                        data = xmlhttp.responseText;
                    }
                    callback(data);
                }
            };

            xmlhttp.open('GET', file, async);
            xmlhttp.send();
        },

        report: function(message) {
            // display report
            console.log(message);
        },

        displayError: function(errorMessage) {
            var errorText = '\n*** Error ***\n';
            // throw an exception
            throw errorText + errorMessage;
            //console.log(errorText + errorMessage);
        },

        random: function(minRange, maxRange) {
            if(typeof minRange === 'undefined') {
                var minRange = 0;
            }
            var range = maxRange - minRange;
            if(range <= 0){
                range = maxRange;
                minRange = 0;
            }
            // returns a random number between 1 and number
            var number = (Math.floor((Math.random() * range)) + minRange);
            return number;
        },

        cleanString: function(string) {
            // removes whitespace, and converts to lowercase
            var cleanedString = string.replace(/[^a-z0-9_]+]/gi, '');
            return cleanedString.toLowerCase();
        },
        
        newElement: function(id, type, cssClass, style) {
            var object = document.createElement(type),
                objectId = applicationId + '_' + id;

            if(id) {
                object.setAttribute('id', objectId);
            }

            if(cssClass) {
                object.setAttribute('class', cssClass);
            }

            if(style) {
                css.style(object, style); // test for bug here with the reference
            }

            return object;
        },

        secondsToMinutes: function(number) {
            // unfinished

            var rounded = Math.round(number);
            return rounded;
        }
    };

    var css = (function() {

        return {
            style: function(element, object) {
                for(var attribute in object)
                {
                    var value = object[attribute];

                    switch(attribute)
                    {
                        case 'width':
                        case 'height':
                        case 'top':
                        case 'left':
                        case 'right':
                        case 'bottom':
                            value = value + 'px';
                    }
                    element.style[attribute] = value;
                }
            },

            animate: function(element, parameter, startValue, endValue, time, callback, steps) {
                var currentValue,
                    numberOfSteps,
                    currentStep,
                    difference,
                    timeStep,
                    valueStep,
                    styles = {},
                    step;

                if(typeof steps !== 'number') {
                    steps = 4; // the more steps the smoother the animation, default is 4
                }

                numberOfSteps = steps;
                currentStep = 0;
                difference = endValue - startValue;
                timeStep = time / steps;
                valueStep = difference / steps;
                step = setInterval(function() {
                    if(currentStep > steps) {
                        clearInterval(step);
                        if(callback) {
                            callback();
                        }
                    } else {
                        if(currentStep === steps) {
                            currentValue = endValue;
                        } else {
                            currentValue = startValue + (valueStep * currentStep);
                        }
                        styles[parameter] = currentValue;
                        css.style(element, styles);
                        currentStep = currentStep + 1;
                    }
                }, timeStep);
                return step;
            },

            interrupt: function(interval) {
                clearInterval(interval);
            }
        }
    })();

    var gui = (function() {

        var id = 'gui',
            container = pack(id, 'div'),
            shadow = pack('gui__shadow', 'div'),
            btnGroup = pack('gui_group', 'div'),
            btnGroupLeft = pack('gui_group_left', 'div'),
            btnGroupRight = pack( 'gui_group_right', 'div'),
            timeGroup = pack('gui_timeGroup', 'div'),
            playPause = pack( 'gui__playPause', 'div', ['gui_bhv_hover', 'gui_bhv_release'], true),
            rewind = pack('gui__rewind', 'div', ['gui_bhv_hover', 'gui_bhv_release']),
            skip = pack('gui__skip', 'div', ['gui_bhv_hover', 'gui_bhv_release']),
            subtitles = pack('gui_subtitles', 'div', ['gui_bhv_hover', 'gui_bhv_release']),
            share = pack('gui__share', 'div', ['gui_bhv_hover', 'gui_bhv_release']),
            fullscreen = pack('gui__fullscreen', 'div', ['gui_bhv_hover', 'gui_bhv_release']),
            timeElapsed = pack('gui__elapsed', 'span'),
            timeDuration = pack('gui__duration', 'span'),
            timeSlider = pack('gui__timeSlider', 'div'),
            enabled = true, // is the gui enabled
            active = false, // is it currently being used? note: theres got to be a better way?
            scale, // gui scale - 1 small, 2 medium, 3 large
            status,
            guiAnimate,
            delayGui;

        container.appendChild(shadow);
        container.appendChild(btnGroup);

        btnGroup.appendChild(btnGroupLeft);
        btnGroup.appendChild(btnGroupRight);
        btnGroup.appendChild(timeGroup);

        btnGroupLeft.appendChild(playPause);
        btnGroupLeft.appendChild(rewind);
        btnGroupLeft.appendChild(skip);

        btnGroupRight.appendChild(share);

        timeGroup.appendChild(timeElapsed);
        timeGroup.appendChild(timeSlider);
        timeGroup.appendChild(timeDuration);
        
        function pack(id, type, hoverBehaviour, clickBehaviour) {
            var object;

            object = helper.newElement(id, type);

            object.loomSE_parameters = {
                id: id
            };
            
            if(hoverBehaviour) {
                object.loomSE_parameters.hover = hoverBehaviour;
            }
            if(clickBehaviour) {
                object.loomSE_parameters.click = clickBehaviour;
            }

            return object;
        }

        function switchPlayPause(htmlObject, button, pauseClass, playClass) {

            if(htmlObject.paused === true) {
                button.classList.remove(pauseClass);
                button.classList.add(playClass);
                return;
            }
            if(htmlObject.paused === false) {
                button.classList.remove(playClass);
                button.classList.add(pauseClass);
                return;
            }
        }

        function updateProgressBar() {
            var getDuration = helper.secondsToMinutes(media.getLength()),
                getCurrentTime = helper.secondsToMinutes(media.getCurrentTime()),
                progressWidth = (getCurrentTime / getDuration) * 300;

            css.style(timeSlider, {
                width: progressWidth
            });
        }

        function constructTimeGroup() {

            var getDuration = helper.secondsToMinutes(media.getLength()),
                getCurrentTime = helper.secondsToMinutes(media.getCurrentTime()),
                duration = 0,
                currentTime = 0,
                progressWidth = (getCurrentTime / getDuration) * 300;

            if(isNaN(getCurrentTime)) {
                duration = 0;
            }
            else {
                duration = getDuration;
            }

            if(isNaN(getDuration)) {
                duration = 0;
            }
            else {
                duration = getDuration;
            }

            css.style(timeSlider, {
                width: progressWidth
            });

            timeElapsed.innerHTML = currentTime;
            timeDuration.innerHTML = duration;
        }

        function entryBehaviour() {
            if(enabled === true && active === false) {
                environment.screenObjects.theatre.appendChild(container);
                css.interrupt(guiAnimate); // make sure any running animations are stopped
                if (typeof delayGui === 'number') { // check to see if it is waiting to unload gui
                    clearInterval(delayGui);
                }
                delayGui = setTimeout(function() {
                    constructTimeGroup();
                    updateProgressBar();
                    switchPlayPause(media.object, playPause, 'gui__pause', 'gui__play');
                    css.style(container, {
                        opacity: 0
                    });
                    //environment.screenObjects.overlay.appendChild(container);
                    status = 'showing';
                    guiAnimate = css.animate(container, 'opacity', 0, 1, 200, function () {
                        status = 'shown';
                    }, 10);
                }, 500);
            }
        }

        function exitBehaviour() {
            if(enabled === true && active === false) {
                css.interrupt(guiAnimate);
                delayGui = setTimeout(function() {
                    guiAnimate = css.animate(container, 'opacity', 0.3, 0, 200, function() {
                        environment.screenObjects.theatre.removeChild(container);
                        status = 'hidden';
                    }, 10);
                }, 500);
            }
        }

        function listenForEvents() {

            function listenToChildren(array) {
                if(typeof array.length === 'number') {
                    for(var i=0; i < array.length; i++) {

                        var currentChild = array[i];

                        if(currentChild.loomSE_parameters.hover) {

                            // hover events
                            currentChild.addEventListener('mouseover', function() {
                                active = true;
                                this.classList.remove(this.loomSE_parameters.hover[0]);
                                this.classList.add(this.loomSE_parameters.hover[1]);
                            });

                            array[i].addEventListener('mouseout', function() {
                                active = false;
                                this.classList.remove(this.loomSE_parameters.hover[1]);
                                this.classList.add(this.loomSE_parameters.hover[0]);
                            });
                        }

                        if(currentChild.loomSE_parameters.click) {

                            // click events
                            currentChild.addEventListener('click', function() {

                                // find which button was pressed and add behavours

                                // play pause button
                                if(this.loomSE_parameters.id = 'gui__playPause') {

                                    if(media.object.paused === true) {
                                        media.play();
                                    }
                                    else {
                                        media.pause();
                                    }

                                    switchPlayPause(media.object, playPause, 'gui__pause', 'gui__play')
                                }
                            });
                        }
                    }
                }
            }

            // show / hide gui
            environment.screenObjects.theatre.addEventListener('mouseenter', function() {
                entryBehaviour();
            });
            environment.screenObjects.theatre.addEventListener('mouseleave', function() {
                exitBehaviour();
            });
            
            // change opacity of buttons

            listenToChildren(btnGroupLeft.children);
            listenToChildren(btnGroupRight.children);
        }

        return {
            reveal: function() {
                entryBehaviour();
            },

            hide: function() {
                exitBehaviour();
            },

            enable: function() {
                enabled = true;
            },

            disable: function() {
                enabled = false;
            },

            initialise: function() {
                listenForEvents();
            },

            updateProgressBar: updateProgressBar
        }
    })();

    var environment = (function() {

        var resolution = {
                // default values, overridden by values in script - if set
                minimum: {
                    width: 640,
                    height: 480
                },
                current: {
                    width: null,
                    height: null
                }
            },

            screenObjects = {
                root: {},
                theatre: {},
                overlay: {},
                mediaGroup: {},
                clearOverlay: function() {
                    // this function clears any active on screen events
                    while (this.overlay.firstChild) this.overlay.removeChild(this.overlay.firstChild);
                }
            };

        return {
            reset: function(){
                subtitles.reset();
                environment.screenObjects.clearOverlay();
            },

            resize: function(element, width, height) {
                css.style(element, {
                    'width': width,
                    'height': height
                });
            },

            screenObjects: screenObjects,
            resolution: resolution
        }
    })();

    // Keeps a record of the scenes passed through by the user. Provides some control over how to navigate the history
    var history = (function() {
        var scenes = [];
        return {
            record: function(object) {
                // records scene
                scenes.push(object);
            },

            erase: function() {
                // removes scene

            },

            remind: function() {
                // returns current scene
                var scene = scenes[scenes.length-1];
                return scene;
            },

            rewind: function() {
                // goes back 1 scene & erases current scene
                var scene;
                if(scenes.length > 1){
                    scenes.splice(scenes.length-1, 1);
                }
                scene = scenes[scenes.length-1];
                return scene;
            },

            saveToLocalStorage: function() {
                // save to html5 local storage
            }
        };
    })();

    // Handles the script logic
    var readScript = (function() {
        // --
        // A collection of methods that set process the media elements in the Script
        // --
        function setScene(scriptObject, scene) {
            // --
            // Runs when a new scene is set from the Script
            // Pulls the relevant scene details from the object, resets parameters and launches the process() method.
            // --

            currentScene = new Scene(scene, scriptObject.settings.language, scriptObject.scenes[scene]);

            //check if subtitles should be on
            if(script.settings.subtitles === true) {
                subtitles.on();
            }
            else {
                subtitles.off();
            }
            subtitles.parse(currentScene.subtitles);

            status.media = currentScene.media.type;
            history.record(currentScene);
            process(currentScene);
        }

        function process(scene) {
            // --
            // Processes the current scene
            // --
            // Each scene is composed of a 'media' type, which in turn has 'data' and 'parameters'
            // Each 'media' type also has a number of events

            function scheduleEvents(target, array, callback) {
                // --
                // Schedules timed events for each media element
                // --

                var createEvent;

                for(var i in array){
                    var event = array[i],
                        id = event.call + '_' + i;

                    createEvent = new Event(id, event.call, event.ignored, event.schedule, event.parameters);

                    Event.prototype.schedule = function () {

                        // We calculate the ins and outs here
                        var that = this,
                            timeIn = that.in,
                            timeOut = that.out,
                            timeInLow = timeIn - (mediaTimeEventResolution / 2),
                            timeInHigh = timeIn + (mediaTimeEventResolution / 2),
                            timeOutLow = timeOut - (mediaTimeEventResolution / 2),
                            timeOutHigh = timeOut + (mediaTimeEventResolution / 2);

                        media.listen(function(time) {
                            if(time >= timeInLow && time <= timeInHigh){
                                if(devOptions.verbose === 'full') {
                                    helper.report('[Event] Run: ' + id);
                                    helper.report('[Event] ' + 'T:' + time + ', L:' + timeInLow + ', H:' + timeInHigh);
                                }

                                that.run();
                            }
                            // 'Out'
                            if(time >= timeOutLow && time <= timeOutHigh) {
                                if(devOptions.verbose === 'full') {
                                    helper.report('[Event] Stop: ' + id);
                                    helper.report('[Event] ' + 'T:' + time + ', L:' + timeOutLow + ', H:' + timeOutHigh);
                                }

                                that.stop();
                                //node.remove(document.getElementById(that.id));
                            }
                        });
                    };

                    createEvent.schedule();
                }

                callback();
            }

            media.create(scene.container, scene.media, function(playObject) {

                media.object = playObject;
                // check which media needs to play
                // play video
                if(scene.media.type === 'video') { // TODO need to allow this to accept and process multiple strings
                    //scene.media.video.duration = playObject.duration;

                    // check if video SHOULD autoplay
                    if(media.object.loomSE_parameters.autoplay === true) {
                        media.play();
                    }
                    else {
                        // load poster image
                    }

                    //if(playObject.loop === false && (scene.data.nextSceneByDefault !== null || scene.data.nextnextSceneByDefault !== '')){
                    //    playObject.onended = function(e){
                    //        readScript.setScene(scene.data.nextSceneByDefault);
                    //    };
                    //}

                    // video loop logic must stay here

                    if(media.object.loomSE_parameters.loop === true) {
                        if(media.object.loomSE_parameters.loopIn === 0 && media.object.loomSE_parameters.loopOut === null) {
                            media.object.onended = function(e){
                                console.log('looping from end to beginning');
                                status.control = 'seeking'; // required for media.play check
                                environment.reset();
                                createEvent.resetStatus();
                                media.play(0);
                            };
                        }
                        else {
                            console.log('Im going to loop the video from the in and out points defined');
                            // add loop point as event
                            // for the purposes of our system, in / out points are reversed
                            // (schedule in point is actually loop out point etc)
                            currentScene.events.push(
                                {
                                    call: 'loop',
                                    schedule: {
                                        in: media.object.loomSE_parameters.loopOut,
                                        out: media.object.loomSE_parameters.loopIn
                                    }
                                }
                            );
                        }
                    }
                }

                if(scene.events !== null) {
                    scheduleEvents(media.object, scene.events, function() {});
                }
                else {
                    helper.report('[Events] No events in scene.');
                }
            });
        }

        return {
            setScene: setScene,
            process: process
        };
    })();

    var subtitles = (function() {
        var id = 'subtitle',
            container = helper.newElement(id, 'div', 'subtitle'),
            element = helper.newElement(undefined, 'p'),
            active;
            subtitlesArray = [],
            arrayPosition = 0,
            activeTitle = [0, 0, null, false];

        function parse(url) {
            var rawSubs,
                line,
                newLine = /\n/g;

            function convertToInternalTime(string, h, m, s, ms) {
                var hours = Number(string.slice(h[0], h[1])),
                    minutes = Number(string.slice(m[0], m[1])),
                    seconds = Number(string.slice(s[0], s[1])),
                    milliseconds = Number(string.slice(ms[0], ms[1])) / 1000,
                    time = (hours * 3600) + (minutes * 60) + seconds + milliseconds;

                return time;
            }

            // support for .srt files
            function srt(array) {
                var arrayPush = [],
                    currentRecord,
                    times,
                    timeIn,
                    timeOut,
                    string = '';

                //console.log(array);
                for(var i=0; i < array.length; i++) {
                    currentRecord = array[i];
                    if(isNaN(currentRecord) === false) {
                        //if(typeof currentRecord === 'number') {
                        // push old string to array
                        if(i > 0) {
                            arrayPush = [timeIn, timeOut, string];
                            subtitlesArray.push(arrayPush);
                            string = '';
                        }
                        // skip to next line, we're expecting the times now
                        times = array[i+1];
                        timeIn = (function() {
                            var string = times.slice(0,12);

                            return convertToInternalTime(string, [0,2], [3,5], [6,8], [9,12]);
                        }());
                        timeOut = (function() {
                            var string = times.slice(17,29);

                            return convertToInternalTime(string, [0,2], [3,5], [6,8], [9,12]);
                        }());
                        i++;
                    }
                    else {
                        string = string + ' ' + currentRecord;
                    }
                }
            }

            helper.ajaxRequest(url, null, true, function(data) {
                rawSubs = data.match(/[^\r\n]+/g);
                if(url.endsWith('srt')) {
                    srt(rawSubs);
                }
                else {
                    active = false;
                    return 'No valid subtitles found';
                }
            });
        }

        function check(time) {
            if(active === true) {
                var check = subtitlesArray[arrayPosition]; // pull current record and see if it is ready

                if(check[0] === time || check[0] < time) {

                    // check if preceding subtitle still exists, if it does, remove it
                    if(activeTitle[3] === true) {
                        remove();
                    }

                    activeTitle = check;
                    activeTitle[3] = true; // set visibility flag to true
                    display(activeTitle[2]); // display subtitle
                    arrayPosition++;
                }
            }
        }

        function display(phrase) {
            // if the subtitles weren't meant to be displayed, fall silent
            if(active === true) {
                if(devOptions.verbose === 'full' || devOptions.verbose === 'subtitles') {
                    helper.report('[Subtitle] ' + phrase);
                }
                element.innerHTML = phrase;
                environment.screenObjects.overlay.appendChild(container);
                container.appendChild(element);
                media.listen(remove);
            }
        }

        function remove(time) {
            function destroy() {
                if(activeTitle === true){
                    activeTitle[3] = false;
                    environment.screenObjects.overlay.removeChild(container);
                }
            }

            // check if time is defined
            if(time) {
                if((activeTitle[1] === time || activeTitle[1] < time) && activeTitle[3] === true) {
                    destroy();
                }
            }
            // if not, default behaviour is to remove subtitle
            else {
                destroy();
            }
        }

        function reset(time) {
            if(activeTitle[3] === true){
                activeTitle[3] = false;
                environment.screenObjects.overlay.removeChild(container);
            }
            if(typeof time === 'number' && time !== 0) {
                // find the next subtitle with the timecode
                for(i=0; i<(subtitlesArray.length-1); i++) {
                    var currentRecord = subtitlesArray[i];
                    if(time < currentRecord[0]) {
                        arrayPosition = i;
                        break;
                    }
                }
            }
            else {
                arrayPosition = 0;
            }
        }

        return {
            parse: parse, // parse subtitle file
            check: check, // check if next subtitle is ready to be displayed
            display: display, // show the subtitle
            remove: remove, // remove existing subtitle
            reset: reset, // reset subtitles (fixes to current time index)
            on: function() {
                active = true;
            },
            off: function() {
                active = false
            }
        }
    })();

    // Handles media
    var media = (function() {

        // internal functions
        var poster = (function() {
            var id = 'poster',
                container = helper.newElement(id, 'div'),
                customPoster,
                type = 'none'; //  (beta) type of transition for removing poster - 'slideUp', 'fade'

            return {
                set: function(image) {
                    css.style(container, {
                        height: environment.resolution.current.height,
                        width: environment.resolution.current.width,
                        'background-image': 'url(' + image + ')',
                        'background-repeat': 'none',
                        'background-position': 'top left',
                        position: 'absolute',
                        top: 0,
                        opacity: 1
                    });
                    environment.screenObjects.overlay.appendChild(container);
                    customPoster = true;
                },
                reveal: function() {
                    if(customPoster === true) {
                        //css.interrupt();
                        css.style(container, {
                            top: 0,
                            opacity: 1
                        });
                        //css.animate(container, 'opacity', 0, 1, 10000, undefined, 100);
                        //helper.animateCSS(container, 'opacity', 0, 1, 10000, undefined, 100);
                    }
                },
                hide: function() {
                    if(customPoster === true && type === 'slideUp') {
                        css.animate(container, 'top', 0, -(environment.resolution.current.height), 1500, undefined, 100);
                        //helper.animateCSS(container, 'top', 0, -(environment.resolution.current.height), 1500, undefined, 100);
                        css.animate(container, 'opacity', 1, 0, 600, undefined, 100);
                        //helper.animateCSS(container, 'opacity', 1, 0, 600, undefined, 100);
                    }
                    if(customPoster === true && type === 'fade') {
                        css.animate(container, 'opacity', 1, 0, 600, undefined, 100);
                        //helper.animateCSS(container, 'opacity', 1, 0, 600, undefined, 100);
                    }
                    if(customPoster === true && type === 'none') {
                        css.style(container, {
                            top: 0,
                            opacity: 0
                        });
                    }
                }
            }
        })();

        var poll = (function() {
            var pollEvent,
                pollInterval = 300,
                playbackStopEvents = 0,
                playBackStopState = false;

            return {
                run: function(object) {
                    var oldTime = object.currentTime,
                        newTime;

                    pollEvent = setInterval(function() {
                        newTime = object.currentTime;
                        // perform analysis
                        if(oldTime !== newTime) {
                            // all ok
                            if(playBackStopState === true) {
                                playBackStopState = false;
                                notify.dismiss();
                            }
                            oldTime = newTime;
                        }
                        else {
                            // else do this if playback has stopped
                            if(devOptions.verbose === 'full' || devOptions.verbose === 'minimal') {
                                console.log('[Poll] Video has stopped playing.');
                            }
                            if(playBackStopState === false) { // check if it hasn't stopped before
                                if(devOptions.verbose === 'full' || devOptions.verbose === 'minimal') {
                                    console.log('[Poll] This is the first time the video has stopped without user input.');
                                }
                                playbackStopEvents = playbackStopEvents + 1;
                            }
                            playBackStopState = true;
                            notify.push('Buffering');
                        }
                    }, pollInterval);
                },
                end: function() {
                    clearInterval(pollEvent);
                }
            }
        })();

        // external functions and variables

        var object;

        function target(sceneId) {
            var parent = document.getElementById(sceneId),
                media = parent.media,
                selection;
            switch (media) {
                case 'video':
                    selection = document.querySelector('video');
                    break;
                case 'audio':
                    selection = document.querySelector('audio');
                    break;
                default:
                    break;
            }
            return selection;
        }

        function pause() {
            if(status.control !== 'paused') {
                notify.push('Video paused');
                poll.end();
                if(devOptions.showPosterWhenPaused === true) {
                    poster.reveal();
                }
                object.pause();
                status.control = 'paused';
            }
        }

        function play(timecode) {
            if(status.media === 'video' || status.media === 'audio') {
                if(status.control === 'waiting' && mediaLoadType === 'full') {
                    // wait for video / audio to fully load
                    // show progress bar
                    notify.push('Loading full');

                    //object.oncanplaythrough = function() {
                        if(devOptions.verbose === 'full' || devOptions.verbose === 'minimal') {
                            console.log('[Media] Fully loaded, playing.');
                        }
                        notify.dismiss();
                        poster.hide();
                        object.play();
                        watch(object);
                        status.control = 'playing';
                    //}
                }

                if(status.control === 'waiting' && mediaLoadType === 'progressive') {
                    // progressively load video / audio and play when enough data is loaded
                    notify.push('Loading prog');

                    //object.oncanplay = function() {
                        if(devOptions.verbose === 'full' || devOptions.verbose === 'minimal') {
                            console.log('[Media] Partially loaded, playing.');
                        }
                        notify.dismiss();
                        poster.hide();
                        object.play();
                        watch(object);
                        poll.run(object);
                        status.control = 'playing';
                    //}
                }

                if(status.control === 'seeking' && typeof timecode === 'number') {
                    object.currentTime = timecode;
                    subtitles.reset(timecode);
                    object.play();
                    object.ontimeupdate = function() {
                        // assuming we don't need this, that the listener remains
                        gui.updateProgressBar();
                    };
                    poll.run(object);
                    status.control = 'playing';
                    return;
                }

                if(object.paused === true && status.control === 'paused') {
                    // check if media was paused, if so, simply unpause

                    notify.dismiss();
                    poster.hide();
                    object.play();
                    object.ontimeupdate = function() {
                        gui.updateProgressBar();
                    };
                    poll.run(object);
                    status.control = 'playing';
                    return;
                }
            }
        }

        function listen(callback) {
            // add an event listener
            media.object.addEventListener('timeupdate', function() {
                callback(media.object.currentTime);
            });
        }

        function watch() {
            // everytime the timecode changes, the following series of actions are taken:
            //  - check to see if any subtitle needs displaying
            //  - check to see if a scene event needs to be fired
            //  - update progress bar
            media.object.ontimeupdate = function() {
                // I begin my watch...
                subtitles.check(media.object.currentTime);
                gui.updateProgressBar();
            };
        }

        function create(container, media, callback) {
            // --
            // Creates a media object and posts to DOM
            // --
            //var mediaElement;

            var Audio = function() {
                // TODO

                return;
            };

            var Graphic = function() {
                
            };

            var Video = function() {
                // --
                // Create video element for screen
                // --

                var element = document.createElement('video'),
                    child1 = document.createElement('source'),
                    child2 = document.createElement('source'),
                    width = environment.screenObjects.mediaGroup.offsetWidth,
                    height = environment.screenObjects.mediaGroup.offsetHeight;

                element.setAttribute('width', width);
                element.setAttribute('height', height);
                element.setAttribute('id', id.video);

                if(typeof media.video.ogg === 'string') {
                    child1.setAttribute('src', media.video.ogg);
                    child1.setAttribute('type', 'video/ogg');
                    element.appendChild(child1);
                }

                if(typeof media.video.mp4 === 'string') {
                    child2.setAttribute('src', media.video.mp4);
                    child2.setAttribute('type', 'video/mp4');
                    element.appendChild(child2);
                }

                if(media.video.poster !== null) {
                    if(devOptions.useAlternativePoster === true) {
                        poster.set(media.video.poster);
                    }
                    else {
                        element.setAttribute('poster', media.video.poster);
                    }
                }

                status.id = id.video;

                element.loomSE_parameters = {};

                if(media.video.muted === true) {
                    element.muted = true;
                }

                // overrides any previous settings
                if(devOptions.muteAudio === true) {
                    element.muted = true;
                }

                if(media.video.controls === true) {
                    element.controls = true;
                    //element.setAttribute('controls', true);
                }

                if(media.video.autoplay === true) {
                    element.loomSE_parameters.autoplay = true;
                }

                if(media.video.loop === true) {
                    element.loomSE_parameters.loop = true;

                    // check if loop in is a number, if it isn't set in point to 0 by default
                    if(typeof media.video.loop_in === 'number') {
                        element.loomSE_parameters.loopIn = media.video.loop_in;
                    } else {
                        element.loomSE_parameters.loopIn = 0;
                    }

                    // check if loop out is a number, if it isn't, default to null
                    if(typeof media.video.loop_out === 'number') {
                        element.loomSE_parameters.loopOut = media.video.loop_out;
                    } else {
                        element.loomSE_parameters.loopOut = null;
                    }
                }

                return element;
            };

            environment.screenObjects.mediaGroup.appendChild(container);

            if(!callback){
                throw 'Expected callback';
            }

            if(media.type === 'audio') {
                callback(audio());
            }
            else if(media.type === 'video') {
                object = new Video();
                container.appendChild(object);
                callback(object);
            }
            else if(media.type === 'graphic') {
                callback(graphic());
            }
            else {
                throw 'Invalid media type';
            }
        }

        function getLength() {
            if(media.object.tagName === 'VIDEO' || media.object.tagName === 'AUDIO') {
                return media.object.duration;
            }
        }

        function getCurrentTime() {
            if(media.object.tagName === 'VIDEO' || media.object.tagName === 'AUDIO') {
                return media.object.currentTime;
            }
        }

        return {
            object: object,
            target: target,
            pause: pause,
            play: play,
            listen: listen,
            watch: watch,
            create: create,
            getLength: getLength,
            getCurrentTime: getCurrentTime
        }
    })();

    var notify = (function() {
        // lowers 'curtain' on screen and pushes notification
        var id = 'notify',
            container = helper.newElement(id, 'div'),
            child = document.createElement('div'),
            child2 = document.createElement('p'),
            isActive = false;

        function position(object) {
            var availableWidth = environment.resolution.current.width,
                availableHeight = environment.resolution.current.height;

            css.style(object, {
                opacity: 0
            });

            var objWidth = object.offsetWidth,
                objHeight = object.offsetHeight,
                x = (availableWidth - objWidth) / 2 ,
                y = (availableHeight - objHeight) / 2;

            css.style(object, {
                position: 'absolute',
                display: 'block',
                left: x,
                top: y,
                opacity: 1
            });
        }

        return {
            push: function(message) {
                if(isActive === false) {
                    isActive = true; // set active flag
                    // create conditions for notification

                    // make child full size of screen
                    //node.maximise(container);

                    // animate the 'curtain falling' on theatre

                    css.animate(environment.screenObjects.stage, 'opacity', 1, 0.2, 200);

                    //helper.animateCSS(environment.screenObjects.stage, 'opacity', 1, 0.2, 200);

                    environment.screenObjects.theatre.appendChild(container);
                    container.appendChild(child);
                    child.appendChild(child2);
                }

                // push notification to screen

                child2.innerHTML = message;
                position(child);
            },

            dismiss: function() {
                if(isActive === false) {
                    return;
                }
                else {
                    // function goes here
                    isActive = false; // reset activity flag
                    environment.screenObjects.theatre.removeChild(container);
                    css.animate(environment.screenObjects.stage, 'opacity', 0.2, 1, 200);
                    //helper.animateCSS(environment.screenObjects.stage, 'opacity', 0.2, 1, 200);
                }
            }
        };
    })();

    // Constructor function that creates instances of each scene
    var Scene = function(title, language, assets) {
        var that = this;
        this.title = title;
        this.shortName = assets.short_name;
        this.longName = assets.long_name;
        this.sceneId = helper.cleanString(this.title);
        this.media = assets.media;
        this.subtitles = assets.media.subtitles[language];
        // why is this not here?
        //if(this.media === 'video') {
        //    this.video = assets.video;
        //}
        //if(this.media === 'audio') {
        //    this.audio = assets.audio;
        //}
        this.events = assets.events;
        this.container = (function() {
            var element = document.createElement('div');
            element.setAttribute('id', that.sceneId);
            element.media = that.media.type;
            return element;
        })();
    };

    // Constructor function that creates instances of each event
    var Event = function(id, call, ignored, schedule, parameters) {
        // not really happy with the way this is defined, but will work for now

        //check if the module reference exists as a function
        if(typeof modules[call] === 'function') {
            var callModule = modules[call]();
        }

        this.status; // waiting, fired, expired, ignored

        if(ignored === true) {
            this.status = 'ignored';
        }
        else {
            this.status = 'waiting';
        }

        this.id = id; // event id
        this.call = call;
        this.status = 'waiting'; // waiting, fired, expired
        this.in = schedule.in / 1000;
        this.out = schedule.out / 1000;
        this.parameters = parameters;
        this.class = parameters.class;
        this.run = function() {
            if(this.status === 'waiting') {
                this.status = 'fired';
                container.loomSE_resolution = {
                    width: environment.resolution.current.width,
                    height: environment.resolution.current.height
                };
                container.loomSE_parameters = this.parameters;
                container.loomSE_schedule = {
                    in: this.in,
                    out: this.out
                };
                environment.screenObjects.overlay.appendChild(container);
                callModule.run(container);
            }
        };
        this.stop = function() {
            if(this.status === 'fired') {
                this.status = 'expired';
                callModule.stop();
                environment.screenObjects.overlay.removeChild(container);
            }
        };
        this.resetStatus = function() {
            this.status = 'waiting';
        };

        var container = helper.newElement(id, 'div', this.class);
    };

    //
    // Public
    //

    var publicMethods = {};

    // namespace for our external modules
    publicMethods.Modules = function() {
    };

    publicMethods.loadSubtitles = function(url) {
        subtitles.parse(url);
    };

    publicMethods.timecode = function() {
        setInterval(function() {
            console.log(media.object.currentTime);
        }, 500);
    };

    publicMethods.events = function() {
        console.log(currentScene.events);
    };

    publicMethods.notify = function(message) {
        // temporary function to test the notification function
        notify.push(message);
    };

    publicMethods.notifyDismiss = function(message) {
        // temporary function to test the notification function
        notify.dismiss();
    };

    publicMethods.eventQueue = function() {
        // temporary function to show event queue
        console.log(events.returnQueue());
    };

    // Properties
    publicMethods.publicProperty = null;

    // Methods
    publicMethods.initialise = function(target, scriptFile, firstScene, resolution, callback) {
        // --
        // Program begins here. Runs once and sets sets up the environment.
        // --

        //var body = document.getElementsByTagName('body');
        //body[0].setAttribute('onresize', 'Loom.control.viewportResize()');

        //window.onresize = Loom.control.viewportResize();

        //window.addEventListener('resize', Loom.rez(), true);k

        //if(environment.check() == false){
        //    console.log('WARNING: Screen too small');
        //}

        // load script file and check the returned data

        helper.ajaxRequest(scriptFile, 'JSON', true, function(returnedData) {
            script = returnedData;

            // this doesnt actually do anything yet
            environment.resolution.minimum.width = script.settings.minimum_resolution.width; // TODO check value is number
            environment.resolution.minimum.height = script.settings.minimum_resolution.height;

            environment.screenObjects.root = document.getElementById(target);
            environment.screenObjects.theatre = document.getElementById(id.theatre);
            environment.screenObjects.stage = document.getElementById(id.stage);
            environment.screenObjects.mediaGroup = document.getElementById(id.mediaGroup);
            environment.screenObjects.overlay = document.getElementById(id.overlay);

            // set our environment
            if(resolution){
                environment.resolution.current.width = resolution[0];
                environment.resolution.current.height = resolution[1];
            }
            else {
                environment.resolution.current.width = window.innerWidth;
                environment.resolution.current.height = window.innerHeight;
            }

            environment.resize(environment.screenObjects.mediaGroup, environment.resolution.current.width, environment.resolution.current.height);
            environment.resize(environment.screenObjects.overlay, environment.resolution.current.width, environment.resolution.current.height);

            modules = new LoomSE.Modules();

            readScript.setScene(script, firstScene);

            // watch for mouse events to activate gui

            gui.initialise();

            if(callback) {
                callback();
            }
        });
    };

    publicMethods.verbose = function() {
        devOptions.verbose = 'full'; // activate verbose mode from console
    };

    publicMethods.status = function() {
        // report stats on media
        // (unfinished)
        var selection = document.getElementById(status.id);

        console.log('Length of media file: ' + selection.duration);
        console.log(status);
    };

    publicMethods.control = (function () {
        // API for system control

        return {
            duration: function() {
                return media.getLength();
            },

            currentTime: function() {
                return media.getCurrentTime();
            },

            gui: (function() {

                return {
                    reveal: function() {
                        gui.reveal();
                    },

                    hide: function() {
                        gui.hide();
                    },

                    enable: function() {
                        gui.enable();
                    },

                    disable: function() {
                        gui.disable();
                    }
                }
            })(),

            pause: function() {
                media.pause();
                return 'Paused';
            },

            play: function() {
                media.play();
                return 'Playing';
            },

            scrub: function(time) {
                // scrub to time in media
                // time in seconds 4 = 4 seconds
                status.control = 'seeking';
                if(devOptions.disableScrubScreen === false) {
                    environment.reset();
                }
                media.play(time);
                return 'Seeking';
            },

            reload: function() {
                // restarts the current scene

                return 'Reloaded scene';
            },

            skip: function(sceneName) {
                // abandon current scene and load the named scene

                return 'Skipped to scene' + sceneName;
            },

            scaleMedia: function(dimensions, location) {
                // resizes currently playing media and repositions it
            },

            viewportResize: function() {
                // resizes the screen
                // node.maximise(environment.screenObjects.mediaGroup);
                // node.maximise(environment.screenObjects.overlay);
                //elements.array.forEach(function(element, index, array){
                //    // find all records that have position information
                //    if(element[1] !== null){
                //        //view.element(document.getElementById(element[0]),{
                //        //    position: element[1]
                //        //}).position();
                //    }
                //    // fullscreen elements
                //    if(element[1] === 'full'){
                //        maxDimensions(document.getElementById(element[0]));
                //    }
                //});
            },

            fullscreen: function() {
                // set app to fullscreen
            }
        };
    })();

    //Return just the public parts
    return publicMethods;
}());